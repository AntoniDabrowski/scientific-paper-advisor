Unnamed: 0,further research line,further research prefix,further research suffix,publication date,title,primary category,categories,authors,abstract,x,y,z,cluster
523,Section 7 contains a discussion of some directions for further research.,"We prove the observation
                                        from [7] that the Cˇ erny´ conjecture holds for completely reachable automata with two input
                                        letters and give some partial results for completely reachable automata with arbitrary input
                                        alphabets.",2.,2022-01-13 16:58:38+00:00,"Completely reachable automata: an interplay between automata, graphs, and trees",cs.FL,"['cs.FL', '68Q45']","[arxiv.Result.Author('Evgeniya A. Bondar'), arxiv.Result.Author('David Casas'), arxiv.Result.Author('Mikhail V. Volkov')]","A deterministic finite automaton in which every non-empty set of states
occurs as the image of the whole state set under the action of a suitable input
word is called completely reachable. We characterize such automata in terms of
graphs and trees.",-0.09393758,-0.16186696,-0.1239711,B
524,"FURTHER WORK

   The results of the present paper suggest several directions for further research.",7.,"Here we
brieﬂy outline two such directions; many further open problem about completely reachable
automata can be found in the ﬁnal sections of [7, 8].",2022-01-13 16:58:38+00:00,"Completely reachable automata: an interplay between automata, graphs, and trees",cs.FL,"['cs.FL', '68Q45']","[arxiv.Result.Author('Evgeniya A. Bondar'), arxiv.Result.Author('David Casas'), arxiv.Result.Author('Mikhail V. Volkov')]","A deterministic finite automaton in which every non-empty set of states
occurs as the image of the whole state set under the action of a suitable input
word is called completely reachable. We characterize such automata in terms of
graphs and trees.",-0.17565097,-0.10708131,-0.036700197,B
2920,"There are two immediate directions for further research: Try to lift our results to (strong)
Muller conditions and to strengthen the lower bounds by proving them for less succinct
representations of F.

   Recall that our lower bounds for weak Muller conditions rely on gadgets comparing n-bit
strings for some ﬁxed n. This is possible for a ﬁxed number of comparisons by having one
gadget for each string to be compared and then using the formula deﬁning F to implement
the actual comparison.","Thus,
the succinctness of weak Muller conditions (encoded by formulas) yields an exponential
increase in comparison to both safety and parity conditions.","A natural way to lift, say the bad j-pair lower bound game is to just
play this game inﬁnitely often.",2022-03-07 13:56:42+00:00,Weakness Makes Muller Delay Games Hard,cs.FL,"['cs.FL', 'cs.LO']","[arxiv.Result.Author('Sarah Winter'), arxiv.Result.Author('Martin Zimmermann')]","We show that solving delay games with winning conditions given by
deterministic and nondeterministic weak Muller automata is 2EXPTIME-complete
respectively 3EXPTIME-complete. Furthermore, doubly and triply exponential
lookahead is necessary and sufficient to win such games. These results are the
first that show that the succinctness of the automata types used to specify the
winning conditions has an influence on the complexity of these problems.",0.15431252,-0.04187812,-0.20812991,A
2921,"There are two immediate directions for further research: Try to lift our results to (standard) Muller
conditions and to strengthen the lower bounds by proving them for less succinct representations of F.

   Recall that our lower bounds for weak Muller conditions rely on gadgets comparing n-bit strings for
some ﬁxed n. This is possible for a ﬁxed number of comparisons by having one gadget for each string
to be compared and then using the formula deﬁning F to implement the actual comparison.","Thus, the succinctness of weak Muller
conditions (encoded by formulas) yields an exponential increase in comparison to both safety and parity
conditions.","A natural
way to lift, say, the bad j-pair lower bound game is to just play this game inﬁnitely often.",2022-03-07 13:56:42+00:00,Weak Muller Conditions Make Delay Games Hard,cs.FL,"['cs.FL', 'cs.LO']","[arxiv.Result.Author('Sarah Winter'), arxiv.Result.Author('Martin Zimmermann')]","We show that solving delay games with winning conditions given by
deterministic and nondeterministic weak Muller automata is 2EXPTIME-complete
respectively 3EXPTIME-complete. Furthermore, doubly and triply exponential
lookahead is necessary and sufficient to win such games. These results are the
first that show that the succinctness of the automata types used to specify the
winning conditions has an influence on the complexity of these problems.",0.15886419,-0.04303123,-0.20812032,A
3560,"We expect that a further study on closure properties will reveal a
       diﬀerent feature of kSDA.","Since we have discussed in this work
       no closure property of kSDA.",5.,2022-03-18 23:44:27+00:00,Between SC and LOGDCFL: Families of Languages Accepted by Logarithmic-Space Deterministic Auxiliary Depth-k Storage Automata,cs.FL,"['cs.FL', 'cs.CC']",[arxiv.Result.Author('Tomoyuki Yamakami')],"The closure of deterministic context-free languages under logarithmic-space
many-one reductions ($\mathrm{L}$-m-reductions), known as LOGDCFL, has been
studied in depth from an aspect of parallel computability because it is nicely
situated between $\mathrm{L}$ and $\mathrm{AC}^1\cap\mathrm{SC}^2$. By changing
a memory device from pushdown stacks to access-controlled storage tapes, we
introduce a computational model of one-way deterministic depth-$k$ storage
automata ($k$-sda's) whose tape cells are freely modified during the first $k$
accesses and then become blank forever. These $k$-sda's naturally induce the
language family $k\mathrm{SDA}$. Similarly to $\mathrm{LOGDCFL}$, we study the
closure $\mathrm{LOG}k\mathrm{SDA}$ of all languages in $k\mathrm{SDA}$ under
$\mathrm{L}$-m-reductions. We first demonstrate that $\mathrm{DCFL}\subseteq
k\mathrm{SDA}\subseteq \mathrm{SC}^k$ by significantly extending Cook's early
result (1979) of $\mathrm{DCFL}\subseteq \mathrm{SC}^2$. The entire hierarch of
$\mathrm{LOG}k\mathrm{SDA}$ for all $k\geq1$ therefore lies between
$\mathrm{LOGDCFL}$ and $\mathrm{SC}$. As an immediate consequence, we obtain
the same simulation bounds for Hibbard's limited automata. We further
characterize the closure $\mathrm{LOG}k\mathrm{SDA}$ in terms of a new machine
model, called logarithmic-space deterministic auxiliary depth-$k$ storage
automata that run in polynomial time. These machines are as powerful as a
polynomial-time two-way multi-head deterministic depth-$k$ storage automata. We
also provide ""generic"" $\mathrm{LOG}k\mathrm{SDA}$-complete languages under
$\mathrm{L}$-m-reductions by constructing a universal simulator working for all
two-way $k$-sda's.",-0.11946397,-0.021992302,0.5643654,B
8701,"The properties of these model types
is a subject of further research.",We distinguish three types.,• With simple control.,2022-07-08 15:48:38+00:00,Global Cellular Automata GCA -- A Massively Parallel Computing Model,cs.FL,"['cs.FL', 'cs.AR', 'nlin.CG', '68W15', 'C.3']",[arxiv.Result.Author('Rolf Hoffmann')],"The Global Cellular Automata (GCA) Model is a generalization of the Cellular
Automata (CA) Model. The GCA model consists of a collection of cells which
change their states depending on the states of their neighbors, like in the
classical CA model. In generalization of the CA model, the neighbors are no
longer fixed and local, they are variable and global. In the basic GCA model, a
cell is structured into a data part and a pointer part. The pointer part
consists of several pointers that hold addresses to global neighbors. The data
rule defines the new data state, and the pointer rule define the new pointer
states. The cell's state is synchronously or asynchronously updated using the
new data and new pointer states. Thereby the global neighbors can be changed
from generation to generation. Similar to the CA model, only the own cell's
state is modified. Thereby write conflicts cannot occur, all cells can work in
parallel which makes it a massively parallel model. The GCA model is related to
the CROW (concurrent read owners write) model, a specific PRAM (parallel random
access machine) model. Therefore many of the well-studied PRAM algorithms can
be transformed into GCA algorithms. Moreover, the GCA model allows to describe
a large number of data parallel applications in a suitable way. The GCA model
can easily be implemented in software, efficiently interpreted on standard
parallel architectures, and synthesized / configured into special hardware
target architectures. This article reviews the model, applications, and
hardware architectures.",0.030376036,0.07520728,0.40468025,B
8948,"Note that there are two question marks in the closure properties columns in Table 1, which we leave for

further research.",The closure properties depicted in Table 1 hold.,Open Problem 2.,2022-07-15 18:34:06+00:00,Parikh Automata over Infinite Words,cs.FL,"['cs.FL', 'cs.LO']","[arxiv.Result.Author('Shibashis Guha'), arxiv.Result.Author('Ismaël Jecker'), arxiv.Result.Author('Karoliina Lehtinen'), arxiv.Result.Author('Martin Zimmermann')]","Parikh automata extend finite automata by counters that can be tested for
membership in a semilinear set, but only at the end of a run, thereby
preserving many of the desirable algorithmic properties of finite automata.
Here, we study the extension of the classical framework onto infinite inputs:
We introduce reachability, safety, B\""uchi, and co-B\""uchi Parikh automata on
infinite words and study expressiveness, closure properties, and the complexity
of verification problems.
  We show that almost all classes of automata have pairwise incomparable
expressiveness, both in the deterministic and the nondeterministic case; a
result that sharply contrasts with the well-known hierarchy in the
$\omega$-regular setting. Furthermore, emptiness is shown decidable for Parikh
automata with reachability or B\""uchi acceptance, but undecidable for safety
and co-B\""uchi acceptance. Most importantly, we show decidability of model
checking with specifications given by deterministic Parikh automata with safety
or co-B\""uchi acceptance, but also undecidability for all other types of
automata. Finally, solving games is undecidable for all types.",-0.11722131,-0.0701304,0.6838658,B
8949,"Let us conclude with the following problem for further research: If a Parikh automaton with, say safety
acceptance, accepts an ω-regular language, is there then an equivalent safety automaton?","However, let us mention that the lack of closure properties severely
limits to chances for a natural fragment of MSO being equivalent to Parikh automata on inﬁnite words.","Stated diﬀerently,
does Parikhness allow to accept more ω-regular languages?",2022-07-15 18:34:06+00:00,Parikh Automata over Infinite Words,cs.FL,"['cs.FL', 'cs.LO']","[arxiv.Result.Author('Shibashis Guha'), arxiv.Result.Author('Ismaël Jecker'), arxiv.Result.Author('Karoliina Lehtinen'), arxiv.Result.Author('Martin Zimmermann')]","Parikh automata extend finite automata by counters that can be tested for
membership in a semilinear set, but only at the end of a run, thereby
preserving many of the desirable algorithmic properties of finite automata.
Here, we study the extension of the classical framework onto infinite inputs:
We introduce reachability, safety, B\""uchi, and co-B\""uchi Parikh automata on
infinite words and study expressiveness, closure properties, and the complexity
of verification problems.
  We show that almost all classes of automata have pairwise incomparable
expressiveness, both in the deterministic and the nondeterministic case; a
result that sharply contrasts with the well-known hierarchy in the
$\omega$-regular setting. Furthermore, emptiness is shown decidable for Parikh
automata with reachability or B\""uchi acceptance, but undecidable for safety
and co-B\""uchi acceptance. Most importantly, we show decidability of model
checking with specifications given by deterministic Parikh automata with safety
or co-B\""uchi acceptance, but also undecidability for all other types of
automata. Finally, solving games is undecidable for all types.",-0.41445488,-0.39849988,-0.22325823,B
8950,"Note that there is one question mark in the closure properties columns in Table 1, which we leave for
further research.",The closure properties depicted in Table 1 hold.,"6 Decision Problems

In this section, we study the complexity of the nonemptiness and the universality problem, model checking,
and solving games for Parikh automata on inﬁnite words.",2022-07-15 18:34:06+00:00,Parikh Automata over Infinite Words,cs.FL,"['cs.FL', 'cs.LO']","[arxiv.Result.Author('Shibashis Guha'), arxiv.Result.Author('Ismaël Jecker'), arxiv.Result.Author('Karoliina Lehtinen'), arxiv.Result.Author('Martin Zimmermann')]","Parikh automata extend finite automata by counters that can be tested for
membership in a semilinear set, but only at the end of a run, thereby
preserving many of the desirable algorithmic properties of finite automata.
Here, we study the extension of the classical framework onto infinite inputs:
We introduce reachability, safety, B\""uchi, and co-B\""uchi Parikh automata on
infinite words and study expressiveness, closure properties, and the complexity
of verification problems.
  We show that almost all classes of automata have pairwise incomparable
expressiveness, both in the deterministic and the nondeterministic case; a
result that sharply contrasts with the well-known hierarchy in the
$\omega$-regular setting. Furthermore, emptiness is shown decidable for Parikh
automata with reachability or B\""uchi acceptance, but undecidable for safety
and co-B\""uchi acceptance. Most importantly, we show decidability of model
checking with specifications given by deterministic Parikh automata with safety
or co-B\""uchi acceptance, but also undecidability for all other types of
automata. Finally, solving games is undecidable for all types.",-0.24407092,-0.27530405,0.10584488,B_centroid
8951,"Let us conclude with the following problem for further research: If a Parikh automaton with, say safety
acceptance, accepts an ω-regular language, is there then an equivalent ω-regular safety automaton?","However, let us mention that the lack of closure properties severely
limits the chances for a natural fragment of MSO being equivalent to Parikh automata on inﬁnite words.","Stated
diﬀerently, does Parikhness allow to accept more ω-regular languages?",2022-07-15 18:34:06+00:00,Parikh Automata over Infinite Words,cs.FL,"['cs.FL', 'cs.LO']","[arxiv.Result.Author('Shibashis Guha'), arxiv.Result.Author('Ismaël Jecker'), arxiv.Result.Author('Karoliina Lehtinen'), arxiv.Result.Author('Martin Zimmermann')]","Parikh automata extend finite automata by counters that can be tested for
membership in a semilinear set, but only at the end of a run, thereby
preserving many of the desirable algorithmic properties of finite automata.
Here, we study the extension of the classical framework onto infinite inputs:
We introduce reachability, safety, B\""uchi, and co-B\""uchi Parikh automata on
infinite words and study expressiveness, closure properties, and the complexity
of verification problems.
  We show that almost all classes of automata have pairwise incomparable
expressiveness, both in the deterministic and the nondeterministic case; a
result that sharply contrasts with the well-known hierarchy in the
$\omega$-regular setting. Furthermore, emptiness is shown decidable for Parikh
automata with reachability or B\""uchi acceptance, but undecidable for safety
and co-B\""uchi acceptance. Most importantly, we show decidability of model
checking with specifications given by deterministic Parikh automata with safety
or co-B\""uchi acceptance, but also undecidability for all other types of
automata. Finally, solving games is undecidable for all types.",-0.42379484,-0.404389,-0.20963001,B
8952,"Note that there is one question mark in the closure properties columns in Table 1, which we leave for
further research.",The closure properties depicted in Table 1 hold.,"6 Decision Problems

In this section, we study the complexity of the nonemptiness and the universality problem, model checking,
and solving games for Parikh automata on inﬁnite words.",2022-07-15 18:34:06+00:00,Parikh Automata over Infinite Words,cs.FL,"['cs.FL', 'cs.LO']","[arxiv.Result.Author('Shibashis Guha'), arxiv.Result.Author('Ismaël Jecker'), arxiv.Result.Author('Karoliina Lehtinen'), arxiv.Result.Author('Martin Zimmermann')]","Parikh automata extend finite automata by counters that can be tested for
membership in a semilinear set, but only at the end of a run, thereby
preserving many of the desirable algorithmic properties of finite automata.
Here, we study the extension of the classical framework onto infinite inputs:
We introduce reachability, safety, B\""uchi, and co-B\""uchi Parikh automata on
infinite words and study expressiveness, closure properties, and the complexity
of verification problems.
  We show that almost all classes of automata have pairwise incomparable
expressiveness, both in the deterministic and the nondeterministic case; a
result that sharply contrasts with the well-known hierarchy in the
$\omega$-regular setting. Furthermore, emptiness is shown decidable for Parikh
automata with reachability or B\""uchi acceptance, but undecidable for safety
and co-B\""uchi acceptance. Most importantly, we show decidability of model
checking with specifications given by deterministic Parikh automata with safety
or co-B\""uchi acceptance, but also undecidability for all other types of
automata. Finally, solving games is undecidable for all types.",-0.24407092,-0.27530405,0.10584488,B
8953,"Let us conclude with the following problem for further research: If a Parikh automaton with, say safety
acceptance, accepts an ω-regular language, is there then an equivalent ω-regular safety automaton?","However, let us mention that the lack of closure properties severely
limits the chances for a natural fragment of MSO being equivalent to Parikh automata on inﬁnite words.","Stated
diﬀerently, does Parikhness allow to accept more ω-regular languages?",2022-07-15 18:34:06+00:00,Parikh Automata over Infinite Words,cs.FL,"['cs.FL', 'cs.LO']","[arxiv.Result.Author('Shibashis Guha'), arxiv.Result.Author('Ismaël Jecker'), arxiv.Result.Author('Karoliina Lehtinen'), arxiv.Result.Author('Martin Zimmermann')]","Parikh automata extend finite automata by counters that can be tested for
membership in a semilinear set, but only at the end of a run, thereby
preserving many of the desirable algorithmic properties of finite automata.
Here, we study the extension of the classical framework onto infinite inputs:
We introduce reachability, safety, B\""uchi, and co-B\""uchi Parikh automata on
infinite words and study expressiveness, closure properties, and the complexity
of verification problems.
  We show that almost all classes of automata have pairwise incomparable
expressiveness, both in the deterministic and the nondeterministic case; a
result that sharply contrasts with the well-known hierarchy in the
$\omega$-regular setting. Furthermore, emptiness is shown decidable for Parikh
automata with reachability or B\""uchi acceptance, but undecidable for safety
and co-B\""uchi acceptance. Most importantly, we show decidability of model
checking with specifications given by deterministic Parikh automata with safety
or co-B\""uchi acceptance, but also undecidability for all other types of
automata. Finally, solving games is undecidable for all types.",-0.42379484,-0.404389,-0.20963001,B
10603,"For further research, the open questions already mentioned should be considered: What is the
relation between the families E C (SLT) and E C (ORD) as well as between the families I C (SLT)
and I C (ORD), especially, is there a language in the set E C (SLT2) \ E C (ORD) or a language in the
set I C (SLT2) \ I C (ORD)?","4 Conclusions

The inclusion relations obtained for the families of languages generated by external or internal contextual
grammars are in most cases the same as for the families where the selection languages are taken from.","Is the family I C (SUF) incomparable to the family I C (SLT) or is it
a proper subset?",2022-08-31 09:29:46+00:00,On the Generative Capacity of Contextual Grammars with Strictly Locally Testable Selection Languages,cs.FL,['cs.FL'],"[arxiv.Result.Author('Jürgen Dassow'), arxiv.Result.Author('Bianca Truthe')]","We continue the research on the generative capacity of contextual grammars
where contexts are adjoined around whole words (externally) or around subwords
(internally) which belong to special regular selection languages. All languages
generated by contextual grammars where all selection languages are elements of
a certain subregular language family form again a language family. We
investigate contextual grammars with strictly locally testable selection
languages and compare those families to families which are based on finite,
monoidal, nilpotent, combinational, definite, suffix-closed, ordered,
commutative, circular, non-counting, power-separating, or union-free languages.",0.14435728,0.05684591,0.22890988,B
10604,"The accepting state complexity for the quotient operation on languages accepted by permutation

automata with larger input alphabets has to be left open and is subject to further research.","We have g−as1c,,PuFA(m, n) = {[10,}mn] oifthmer=w0iseo.r n = 0,

Therefore g−as1c,,PuFA(m, n) = g−as1c,u(m, n).","References

 [1] J. Brzozowski (1980): Open Problems About Regular Languages.",2022-08-31 09:31:25+00:00,On the Accepting State Complexity of Operations on Permutation Automata,cs.FL,"['cs.FL', 'F.1.1;F.1.3']","[arxiv.Result.Author('Christian Rauch'), arxiv.Result.Author('Markus Holzer')]","We investigate the accepting state complexity of deterministic finite
automata for regular languages obtained by applying one of the following
operations to languages accepted by permutation automata: union, quotient,
complement, difference, intersection, Kleene star, Kleene plus, and reversal.
The paper thus joins the study of accepting state complexity of regularity
preserving language operations which was initiated by the work [J. Dassow: On
the number of accepting states of finite automata, J. Autom., Lang. Comb., 21,
2016]. We show that for almost all of the operations, except for reversal and
quotient, there is no difference in the accepting state complexity for
permutation automata compared to deterministic finite automata in general. For
both reversal and quotient we prove that certain accepting state complexities
cannot be obtained; these number are called ""magic"" in the literature.
Moreover, we solve the left open accepting state complexity problem for the
intersection of unary languages accepted by permutation automata and
deterministic finite automata in general.",-0.16243446,-0.17977634,-0.21176347,B
11290,"An interesting direction for further research concerns the complexity of resolving nondeterminism in
history-deterministic Parikh automata.","11
have almost the same closure properties as DPA (complementation being the notable diﬀerence), and enjoy
some of the desirable algorithmic properties of DPA.","It is straightforward to show that every HDPA has a positional
resolver (i.e., one whose decision is only based on the last state of the run constructed thus far and on the
extended Parikh image induced by this run) and that HDPA that have ﬁnite-state resolvers (say, implemented
by a Mealy machine) can be determinized by taking the product of the HDPA and the Mealy machine.",2022-09-16 07:03:40+00:00,History-deterministic Parikh Automata,cs.FL,['cs.FL'],"[arxiv.Result.Author('Enzo Erlich'), arxiv.Result.Author('Shibashis Guha'), arxiv.Result.Author('Ismaël Jecker'), arxiv.Result.Author('Karoliina Lehtinen'), arxiv.Result.Author('Martin Zimmermann')]","Parikh automata extend finite automata by counters that can be tested for
membership in a semilinear set, but only at the end of a run. Thereby, they
preserve many of the desirable properties of finite automata. Deterministic
Parikh automata are strictly weaker than nondeterministic ones, but enjoy
better closure and algorithmic properties. This state of affairs motivates the
study of intermediate forms of nondeterminism. Here, we investigate
history-deterministic Parikh automata, i.e., automata whose nondeterminism can
be resolved on the fly. This restricted form of nondeterminism is well-suited
for applications which classically call for determinism, e.g., solving games
and composition. We show that history-deterministic Parikh automata are
strictly more expressive than deterministic ones, incomparable to unambiguous
ones, and enjoy almost all of the closure and some of the algorithmic
properties of deterministic automata.",-0.25889248,-0.06598021,-0.09486315,B
12686,"There are several questions about the expressivity of history-deterministic
OCNs which we believe need further study.","One could
also ask, for instance, to look at reachability or Büchi and co-Büchi acceptance
conditions and understand how history-determinism works in these models.","We have shown that

                             DOCN ⊆ HOCN ⊆ OCN ∩ DOCA.",2022-10-18 18:27:03+00:00,On History-Deterministic One-Counter Nets,cs.FL,"['cs.FL', 'F.4.3']","[arxiv.Result.Author('Aditya Prakash'), arxiv.Result.Author('K. S. Thejaswini')]","We consider the model of history-deterministic one-counter nets (OCNs).
History-determinism is a property of transition systems that allows for a
limited kind of non-determinism which can be resolved 'on-the-fly'. Token
games, which have been used to characterise history-determinism over various
models, also characterise history-determinism over OCNs. By reducing 1-token
games to simulation games, we are able to show that checking for
history-determinism of OCNs is decidable. Moreover, we prove that this problem
is PSPACE-complete for a unary encoding of transitions, and EXPSPACE-complete
for a binary encoding.
  We then study the language properties of history-deterministic OCNs. We show
that the resolvers of non-determinism for history-deterministic OCNs are
eventually periodic. As a consequence, for a given history-deterministic OCN,
we construct a language equivalent deterministic one-counter automaton. We also
show the decidability of comparing languages of history-deterministic OCNs,
such as language inclusion and language universality.",-0.24829894,0.7815714,-0.16537711,C_centroid
12687,"There are several questions about the expressivity of history-deterministic
OCNs which we believe need further study.","One could
also ask, for instance, to look at reachability or Büchi and co-Büchi acceptance
conditions and understand how history-determinism works in these models.","We have shown that

                             DOCN ⊆ HOCN ⊆ OCN ∩ DOCA.",2022-10-18 18:27:03+00:00,On History-Deterministic One-Counter Nets,cs.FL,"['cs.FL', 'F.4.3']","[arxiv.Result.Author('Aditya Prakash'), arxiv.Result.Author('K. S. Thejaswini')]","We consider the model of history-deterministic one-counter nets (OCNs).
History-determinism is a property of transition systems that allows for a
limited kind of non-determinism which can be resolved 'on-the-fly'. Token
games, which have been used to characterise history-determinism over various
models, also characterise history-determinism over OCNs. By reducing 1-token
games to simulation games, we are able to show that checking for
history-determinism of OCNs is decidable. Moreover, we prove that this problem
is PSPACE-complete for a unary encoding of transitions, and EXPSPACE-complete
for a binary encoding.
  We then study the language properties of history-deterministic OCNs. We show
that the resolvers of non-determinism for history-deterministic OCNs are
eventually periodic. As a consequence, for a given history-deterministic OCN,
we construct a language equivalent deterministic one-counter automaton. We also
show the decidability of comparing languages of history-deterministic OCNs,
such as language inclusion and language universality.",-0.24829894,0.7815714,-0.16537711,C
12688,"There are several questions about the expressivity of history-deterministic
OCNs which we believe need further study.","One could
also ask, for instance, to look at reachability or Büchi and co-Büchi acceptance
conditions and understand how history-determinism works in these models.","We have shown that

                             DOCN ⊆ HOCN ⊆ OCN ∩ DOCA.",2022-10-18 18:27:03+00:00,On History-Deterministic One-Counter Nets,cs.FL,"['cs.FL', 'F.4.3']","[arxiv.Result.Author('Aditya Prakash'), arxiv.Result.Author('K. S. Thejaswini')]","We consider the model of history-deterministic one-counter nets (OCNs).
History-determinism is a property of transition systems that allows for a
limited kind of non-determinism which can be resolved 'on-the-fly'. Token
games, which have been used to characterise history-determinism over various
models, also characterise history-determinism over OCNs. By reducing 1-token
games to simulation games, we are able to show that checking for
history-determinism of OCNs is decidable. Moreover, we prove that this problem
is PSPACE-complete for a unary encoding of transitions, and EXPSPACE-complete
for a binary encoding.
  We then study the language properties of history-deterministic OCNs. We show
that the resolvers of non-determinism for history-deterministic OCNs are
eventually periodic. As a consequence, for a given history-deterministic OCN,
we construct a language equivalent deterministic one-counter automaton. We also
show the decidability of comparing languages of history-deterministic OCNs,
such as language inclusion and language universality.",-0.24829894,0.7815714,-0.16537711,C
14455,"Section 5 concludes the paper with a
summary and outline of directions for further research.","Section 4 proves that the algorithm for calculating the probabil-
ity of deriving a given expression with any given PCFG does not exist and
presents exact and approximate algorithms for grammars generating linear,
polynomial, and rational expressions.",2.,2022-12-01 18:36:54+00:00,P(Expression|Grammar): Probability of deriving an algebraic expression with a probabilistic context-free grammar,cs.FL,"['cs.FL', 'cs.LG']","[arxiv.Result.Author('Urh Primozič'), arxiv.Result.Author('Ljupčo Todorovski'), arxiv.Result.Author('Matej Petković')]","Probabilistic context-free grammars have a long-term record of use as
generative models in machine learning and symbolic regression. When used for
symbolic regression, they generate algebraic expressions. We define the latter
as equivalence classes of strings derived by grammar and address the problem of
calculating the probability of deriving a given expression with a given
grammar. We show that the problem is undecidable in general. We then present
specific grammars for generating linear, polynomial, and rational expressions,
where algorithms for calculating the probability of a given expression exist.
For those grammars, we design algorithms for calculating the exact probability
and efficient approximation with arbitrary precision.",0.6932914,-0.06915212,-0.04417754,A
14456,Two venues for further research emerge.,"Finally, we show that the exact probability can be eﬃciently
approximated to a speciﬁed precision.","First, a relevant open question
for symbolic regression is what would be a most general restriction of the
»Richardson« universal grammar presented in Section 4 that would allow
for an algorithmic solution for calculating the probability of a given expres-
sion.",2022-12-01 18:36:54+00:00,P(Expression|Grammar): Probability of deriving an algebraic expression with a probabilistic context-free grammar,cs.FL,"['cs.FL', 'cs.LG']","[arxiv.Result.Author('Urh Primozič'), arxiv.Result.Author('Ljupčo Todorovski'), arxiv.Result.Author('Matej Petković')]","Probabilistic context-free grammars have a long-term record of use as
generative models in machine learning and symbolic regression. When used for
symbolic regression, they generate algebraic expressions. We define the latter
as equivalence classes of strings derived by grammar and address the problem of
calculating the probability of deriving a given expression with a given
grammar. We show that the problem is undecidable in general. We then present
specific grammars for generating linear, polynomial, and rational expressions,
where algorithms for calculating the probability of a given expression exist.
For those grammars, we design algorithms for calculating the exact probability
and efficient approximation with arbitrary precision.",0.5801591,-0.09237305,-0.2583199,A_centroid
14457,"Section 5 concludes the paper with a
summary and outline of directions for further research.","Section 4 proves that the algorithm for calculating the probabil-
ity of deriving a given expression with any given PCFG does not exist and
presents exact and approximate algorithms for grammars generating linear,
polynomial, and rational expressions.",2.,2022-12-01 18:36:54+00:00,P(Expression|Grammar): Probability of deriving an algebraic expression with a probabilistic context-free grammar,cs.FL,"['cs.FL', 'cs.LG']","[arxiv.Result.Author('Urh Primožič'), arxiv.Result.Author('Ljupčo Todorovski'), arxiv.Result.Author('Matej Petković')]","Probabilistic context-free grammars have a long-term record of use as
generative models in machine learning and symbolic regression. When used for
symbolic regression, they generate algebraic expressions. We define the latter
as equivalence classes of strings derived by grammar and address the problem of
calculating the probability of deriving a given expression with a given
grammar. We show that the problem is undecidable in general. We then present
specific grammars for generating linear, polynomial, and rational expressions,
where algorithms for calculating the probability of a given expression exist.
For those grammars, we design algorithms for calculating the exact probability
and efficient approximation with arbitrary precision.",0.6932914,-0.06915212,-0.04417754,A
14458,Two venues for further research emerge.,"Finally, we show that the exact probability can be eﬃciently
approximated to a speciﬁed precision.","First, a relevant open question
for symbolic regression is what would be a most general restriction of the
»Richardson« universal grammar presented in Section 4 that would allow
for an algorithmic solution for calculating the probability of a given expres-
sion.",2022-12-01 18:36:54+00:00,P(Expression|Grammar): Probability of deriving an algebraic expression with a probabilistic context-free grammar,cs.FL,"['cs.FL', 'cs.LG']","[arxiv.Result.Author('Urh Primožič'), arxiv.Result.Author('Ljupčo Todorovski'), arxiv.Result.Author('Matej Petković')]","Probabilistic context-free grammars have a long-term record of use as
generative models in machine learning and symbolic regression. When used for
symbolic regression, they generate algebraic expressions. We define the latter
as equivalence classes of strings derived by grammar and address the problem of
calculating the probability of deriving a given expression with a given
grammar. We show that the problem is undecidable in general. We then present
specific grammars for generating linear, polynomial, and rational expressions,
where algorithms for calculating the probability of a given expression exist.
For those grammars, we design algorithms for calculating the exact probability
and efficient approximation with arbitrary precision.",0.5801591,-0.09237305,-0.2583199,A
14826,"I am sure that this book will
stimulate much further research in this exciting area.","This systematic presentation
of large parts of recent research is therefore very valuable and right in time.","Leipzig, December 2022
Manfred Droste
Contents

1 Introduction                            1

2 Preliminaries                           11

2.1 Numbers and sets .",2022-12-11 15:56:28+00:00,Weighted Tree Automata -- May it be a little more?,cs.FL,['cs.FL'],"[arxiv.Result.Author('Zoltán Fülöp'), arxiv.Result.Author('Heiko Vogler')]","This is a book on weighted tree automata. We present the basic definitions
and some of the important results in a coherent form with full proofs. The
concept of weighted tree automata is part of Automata Theory and it touches the
area of Universal Algebra. It originated from two sources: weighted string
automata and finite-state tree automata.",0.16958448,0.20486662,0.14086768,A
15221,"For this to work, we would have to connect e and f with
their interpretations inside this KA, which will require further research.","There is a tantalizing candidate for a canonical model that might be able to
ﬁll the role of P(MAe+f ) in the previous section: simply use the relational KA
with the carrier MAe+f .","Completeness and the FMP for KA, reconsidered  15

Acknowledgements The author wishes to thank Nick Bezhanishvili for his sug-
gestion to investigate the FMP for KA, Alexandra Silva for general advice about
this manuscript, and the anonymous reviewers for their careful comments.",2022-12-21 11:20:13+00:00,"Completeness and the Finite Model Property for Kleene Algebra, Reconsidered",cs.FL,"['cs.FL', 'cs.LO']",[arxiv.Result.Author('Tobias Kappé')],"Kleene Algebra (KA) is the algebra of regular expressions. Central to the
study of KA is Kozen's (1994) completeness result, which says that any
equivalence valid in the language model of KA follows from the axioms of KA.
Also of interest is the finite model property (FMP), which says that false
equivalences always have a finite counterexample. Palka (2005) showed that, for
KA, the FMP is equivalent to completeness.
  We provide a unified and elementary proof of both properties. In contrast
with earlier completeness proofs, this proof does not rely on minimality or
bisimilarity techniques for deterministic automata. Instead, our approach
avoids deterministic automata altogether, and uses Antimirov's derivatives and
the well-known transition monoid construction.
  Our results are fully verified in the Coq proof assistant.",0.21828806,0.09103906,0.39281365,A
